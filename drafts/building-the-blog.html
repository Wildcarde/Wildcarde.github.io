<!DOCTYPE html>
<html lang="en">
<head>
          <title>Putting the Pieces Together</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <!-- twitter card metadata -->
<meta name="twitter:site" content="@Wildcarde815">
<meta name="twitter:title" content="Building the Blog">
<meta name="twitter:description" content="">
        <!-- OG Tags -->
<meta property="og:url" content="https://blog.shadowgears.com/drafts/building-the-blog.html"/>
<meta property="og:title" content="Putting the Pieces Together | Building the Blog" />
<meta property="og:description" content="" />
        <!-- favicon -->
        <!-- moment.js for date formatting -->
        <script src="https://blog.shadowgears.com/theme/js/moment.js"></script>
        <!-- css -->
        <link rel="stylesheet" type="text/css" href="https://blog.shadowgears.com/theme/css/main.css" />
		<script>
			
                /*! grunt-grunticon Stylesheet Loader - v2.1.2 | https://github.com/filamentgroup/grunticon | (c) 2015 Scott Jehl, Filament Group, Inc. | MIT license. */
    
    (function(e){function t(t,n,r,o){"use strict";function a(){for(var e,n=0;u.length>n;n++)u[n].href&&u[n].href.indexOf(t)>-1&&(e=!0);e?i.media=r||"all":setTimeout(a)}var i=e.document.createElement("link"),l=n||e.document.getElementsByTagName("script")[0],u=e.document.styleSheets;return i.rel="stylesheet",i.href=t,i.media="only x",i.onload=o||null,l.parentNode.insertBefore(i,l),a(),i}var n=function(r,o){"use strict";if(r&&3===r.length){var a=e.navigator,i=e.Image,l=!(!document.createElementNS||!document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||e.opera&&-1===a.userAgent.indexOf("Chrome")||-1!==a.userAgent.indexOf("Series40")),u=new i;u.onerror=function(){n.method="png",n.href=r[2],t(r[2])},u.onload=function(){var e=1===u.width&&1===u.height,a=r[e&&l?0:e?1:2];n.method=e&&l?"svg":e?"datapng":"png",n.href=a,t(a,null,null,o)},u.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",document.documentElement.className+=" grunticon"}};n.loadCSS=t,e.grunticon=n})(this);(function(e,t){"use strict";var n=t.document,r="grunticon:",o=function(e){if(n.attachEvent?"complete"===n.readyState:"loading"!==n.readyState)e();else{var t=!1;n.addEventListener("readystatechange",function(){t||(t=!0,e())},!1)}},a=function(e){return t.document.querySelector('link[href$="'+e+'"]')},c=function(e){var t,n,o,a,c,i,u={};if(t=e.sheet,!t)return u;n=t.cssRules?t.cssRules:t.rules;for(var l=0;n.length>l;l++)o=n[l].cssText,a=r+n[l].selectorText,c=o.split(");")[0].match(/US\-ASCII\,([^"']+)/),c&&c[1]&&(i=decodeURIComponent(c[1]),u[a]=i);return u},i=function(e){var t,o,a;o="data-grunticon-embed";for(var c in e)if(a=c.slice(r.length),t=n.querySelectorAll(a+"["+o+"]"),t.length)for(var i=0;t.length>i;i++)t[i].innerHTML=e[c],t[i].style.backgroundImage="none",t[i].removeAttribute(o);return t},u=function(t){"svg"===e.method&&o(function(){i(c(a(e.href))),"function"==typeof t&&t()})};e.embedIcons=i,e.getCSS=a,e.getIcons=c,e.ready=o,e.svgLoadedCallback=u,e.embedSVG=u})(grunticon,this);
                
                grunticon(["https://blog.shadowgears.com/theme/css/icons.data.svg.css", "https://blog.shadowgears.com/theme/css/icons.data.png.css", "https://blog.shadowgears.com/theme/css/icons.fallback.css"]);
            </script>
        <noscript><link href="https://blog.shadowgears.com/theme/css/icons.fallback.css" rel="stylesheet"></noscript>
        <!-- menu toggle javascript -->
        <script type="text/javascript">
            document.addEventListener("DOMContentLoaded", initMenu);
            
            function initMenu(){
                var menu = document.getElementById("menu");
                var menulink = document.getElementById("menu-link");
                menulink.addEventListener("click", function toggleMenu(){
                        window.event.preventDefault();
                        menulink.classList.toggle('active');
                        menu.classList.toggle('active');              
                    });
            };
        </script>


    <meta name="tags" content="deployment" />
    <meta name="tags" content="blog" />

</head>
<body>
    <div role="banner" id="masthead">
        <header>
            <h1><a href="/">Garrett's Blog</a></h1>
            <a href="#menu" id="menu-link">more stuff</a>
            <nav id="menu">
                <ul>
                            <li><a href="https://blog.shadowgears.com/category/glass-canopy.html">Glass Canopy</a></li>
                </ul>
            </nav>
        </header>
    </div>
        <div class="page" role="main">
  <div class="article" role="article">
    <article>
        <footer>
            <a name="top"></a>
            <p>
              <time datetime=" 2021-02-14 04:22:00-05:00">
                <script>document.write(moment('2021-02-14 04:22:00-05:00').format('LL'));</script>
              </time>
            </p>
        </footer>
        <header>
          <h2>
            Building the Blog
          </h2>
        </header>
      <div class="content">
         <p>It's been a while since I've spent any serious time looking at blogging, static site generation, and the github pages system so it was no surprise that my knowledge was more than a little out of date.  What was surprising however was how much information online seems to be equally out of date at this point a state that was a little disappointing but not overtly surprising.  It's not like github shouts from the rooftop when they change things quietly in the background, especially when those old approaches still work.  </p>
<p>So this post will serve somewhat as modern documentation for how github user pages can be setup and automated to use <a href="https://blog.getpelican.com/">Pelican</a> to generate a blog (like this one).</p>
<h2>How things used to work</h2>
<p>Originally what you would do is create a public repository named <code>&lt;githubuser&gt;.github.io</code>.  From here the <code>main</code> or <code>master</code> branch in the repository would be your raw content, so in pelican a folder full of markdown files.  From there you'd generate an output folder, that typically you would not capture in git, and merge that into a separate branch named <code>gh-pages</code>.  This felt like creating some sort of weird hell alternate file stream based approach and was generally kinda difficult to wrap your head around.  The alternative was brute forcing it by simply checking out two different copies of the same repo in separate folders, then just copy/pasting from one to the other and pushing.  This works but at that point, why have them be the same repo?  I suspect this is something github realized somewhere along the way because that's how you do it now!</p>
<h2>Structure</h2>
<p>Github has simplified things a bit, now you can just put your websites static folder in the main branch (<code>main</code> or <code>master</code> depending on repo settings and age).  This allows us some flexibility, the core of this blog is published from a private repository allowing me to not exposed my pelican configs, comment cruft, in dev theme files, and other details around how pelican sites are published in the public repository that serves out what you are reading.</p>
<p>To get started I made a conda environment to use for local test builds, it's overkill but miniconda envs are my default approach, to this we need to add the following packages (this is the contents of my <code>requirements.txt</code> file, but using the latest versions should work; you might not even need all of this):</p>
<div class="highlight"><pre><span></span><code><span class="na">blinker</span><span class="o">=</span><span class="s">=1.4</span>
<span class="na">docutils</span><span class="o">=</span><span class="s">=0.16</span>
<span class="na">feedgenerator</span><span class="o">=</span><span class="s">=1.9.1</span>
<span class="na">Jinja2</span><span class="o">=</span><span class="s">=2.11.3</span>
<span class="na">Markdown</span><span class="o">=</span><span class="s">=3.2.2</span>
<span class="na">MarkupSafe</span><span class="o">=</span><span class="s">=1.1.1</span>
<span class="na">pelican</span><span class="o">=</span><span class="s">=4.5.4</span>
<span class="na">pelican-render-math</span><span class="o">=</span><span class="s">=1.0.3</span>
<span class="na">Pygments</span><span class="o">=</span><span class="s">=2.6.1</span>
<span class="na">python-dateutil</span><span class="o">=</span><span class="s">=2.8.1</span>
</code></pre></div>


<p>After that environment is created and activated the private repo needs to be cloned into a local folder, and cd'd into so it's your working directory. At this point the basic pelican environment can be created with the <code>pelican-quickstart</code> command, this will create the default folder structure and config files needed to get everything running. Before adding and committing these changes add a quick <code>.gitignore</code> file with the following ignores:</p>
<div class="highlight"><pre><span></span><code><span class="nf">__pycache__</span>
<span class="na">.vscode</span><span class="err">/</span><span class="p">*</span>

<span class="nf">output</span><span class="err">/</span><span class="p">*</span>
</code></pre></div>


<p>Once the above is added to git it can be committed and pushed up to the private repository.  This sets up the base you need to build on going forward.</p>
<h3>Custom URL</h3>
<p>If using a custom url (like say <code>blog.shadowgears.com</code>) you'll need to do a few things:</p>
<p>1) make a folder inside your <code>content</code> folder named <code>extra</code> and add a file named <code>CNAME</code> with the custom domain name in it, that will handle the CNAME id file required by <a href="https://docs.github.com/en/github/working-with-github-pages/configuring-a-custom-domain-for-your-github-pages-site">github pages</a>.
2) Add the following to your <code>pelicanconf.py</code> file:</p>
<div class="highlight"><pre><span></span><code><span class="n">STATIC_PATHS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;extra&#39;</span><span class="p">,</span><span class="s1">&#39;extra/CNAME&#39;</span><span class="p">]</span>  <span class="c1">#this flags these folders as &#39;static&#39; they will not be run through any parsers</span>
<span class="n">EXTRA_PATH_METADATA</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;extra/CNAME&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="s1">&#39;CNAME&#39;</span><span class="p">}}</span> <span class="c1">#this takes the file and puts it at the root of the published directory and names it CNAME per the requirements in the github pages docs</span>
</code></pre></div>


<p>3) Add the following to your <code>publishconf.py</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">SITEURL</span> <span class="o">=</span> <span class="s1">&#39;https://&lt;your site url here&gt;&#39;</span>
</code></pre></div>


<p>Adding the above will ensure that the file <code>CNAME</code> is placed in the root of your output folder every time the site is generated so even if it's removed by accident it'll be re-instated on the next publish.  Additionally setting the siteurl will make sure all internal links on the site point to the correct location when the site is published.</p>
<h2>Auto Publishing Posts</h2>
<p>At this point you can publish the content, using the <code>make publish</code> command will push a full processed copy of the content folder to <code>output</code>, and for some that's probably anywhere between good and fine. But that's not something I want to have to remember every time I write something new, so the next step is to solve automatic publishing!  We'll be pushing from our private repository to the public one so we are going to need a <a href="https://github.com/settings/tokens">personal access token</a> with the <code>repo-&gt;public repo</code> privileges, I've tested no additional privileges are required.  Make sure you note this key value down somewhere you can copy / paste it.</p>
<p>The next step is going to be adding this as a secret attached to your private repository, this is done in the specific private repos <code>settings-&gt;secrets</code>, simply add a new secret named <code>APITOKENPUBLISH</code> and paste the contents of the generated token above in as the value. This will be used by the github action we'll be setting up next.</p>
<p>Now that we've got the basics needed to make this work all that's required is adding the automatic workflow to the private repository.  This will be broken into a few steps:</p>
<p>1) Checkout a copy of the repository.
2) Run <code>make publish</code> on the contents of the repository.
3) Clone the public repository into a separate location, copy the output of <code>make publish</code> into it, and push it back out.</p>
<p>To get this started we'll need a new set of folders at the root of the repository named <code>.github/workflows</code>, inside here is where we'll place the rest of the magic.  Once that folder is in-place we are going to need a yaml file inside it, this can be named whatever but I'm going for <code>pelican-publish.yml</code>.  This is going to be a <a href="https://docs.github.com/en/actions/quickstart">github actions</a> file and is the reason we made that secret entry further up the post.  A full copy of the action file is included at the end of this post, the following sections break down the sub parts.</p>
<h3>Setup the Environment</h3>
<p>This initial segment sets up some rules and the python environment.  We'll be naming the action <code>Pelican-Publisher</code>, restricting it to only run on pushes to our source repository, and instructing it to run on ubuntu.  This last part we could probably make something lighter weight just so it runs a little faster (this process is slower than I'd like) but for simplicity and compatibility with most published documentation and actions I stuck with ubuntu here.  The last bits of this step check out the private repository and creates a python environment </p>
<div class="highlight"><pre><span></span><code><span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pelican-Publisher</span>

<span class="c1"># Run this workflow ever time a new commit is pushed ot the repo</span>
<span class="nt">on</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">push</span>

<span class="nt">jobs</span><span class="p">:</span>
  <span class="nt">publish</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Publish</span> 

    <span class="nt">runs-on</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span>

    <span class="nt">steps</span><span class="p">:</span>
      <span class="c1">## pull the committed code into an environment.</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Checkout Code</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">actions/checkout@v2</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Set up Python 3.9</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">actions/setup-python@v2</span>
        <span class="nt">with</span><span class="p">:</span>
          <span class="nt">python-version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3.9</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Install Dependencies</span>
        <span class="nt">run</span><span class="p">:</span> <span class="p p-Indicator">|</span>
          <span class="no">python -m pip install --upgrade pip</span>
          <span class="no">pip install -r requirements.txt</span>
</code></pre></div>


<h3>Build the Website</h3>
<p>This sounds like it should be long or complicated, it's neither.  If test <code>make publish</code> commands worked on the local system the adding this to the above will build the website fresh:</p>
<div class="highlight"><pre><span></span><code>      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Build Site</span>
        <span class="nt">run</span><span class="p">:</span> <span class="p p-Indicator">|</span>
          <span class="no">make publish</span>
</code></pre></div>


<p>If this doesn't work, there's probably an issue with your local <code>make publish</code> or with your requirements file, verify those are correct then revisit this.</p>
<h3>Publish the Website</h3>
<p>The actual complicated part of this is here, we'll be making use of user <a href="https://github.com/cpina">cpina</a>'s <a href="https://github.com/cpina/github-action-push-to-another-repository">github-action-push-to-another-repository</a> published action to do the heavy lifting here.  It'll require a few quick inputs, mostly involving your github ID or the afore mentioned API key secret.</p>
<div class="highlight"><pre><span></span><code>      <span class="c1"># push generated site to public repo</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pushes to another repository</span>
        <span class="nt">id</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">push_directory</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">cpina/github-action-push-to-another-repository@v1.2</span>
        <span class="nt">env</span><span class="p">:</span>
          <span class="nt">API_TOKEN_GITHUB</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">${{ secrets.APITOKENPUBLISH }}</span>
        <span class="nt">with</span><span class="p">:</span>
          <span class="nt">source-directory</span><span class="p">:</span> <span class="s">&#39;output&#39;</span>
          <span class="nt">destination-github-username</span><span class="p">:</span> <span class="s">&#39;&lt;your</span><span class="nv"> </span><span class="s">github</span><span class="nv"> </span><span class="s">id</span><span class="nv"> </span><span class="s">here&gt;&#39;</span>
          <span class="nt">destination-repository-name</span><span class="p">:</span> <span class="s">&#39;&lt;your</span><span class="nv"> </span><span class="s">github</span><span class="nv"> </span><span class="s">id</span><span class="nv"> </span><span class="s">here&gt;.github.io&#39;</span>
          <span class="nt">user-email</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;your email address here so the commit is signed correctly&gt;</span>
          <span class="nt">commit-message</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Automated Update</span>
          <span class="nt">target-branch</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">main</span>
</code></pre></div>


<p>This action does a few things. First it checks out the target repository, in this case our public <code>&lt;username&gt;.github.io</code> repository. Then it makes a new folder and copies just the <code>.git</code> subfolder from the checked out repository into there. Over top of this it copies the contents of the folder <code>output</code>, and finally issues a commit and push of this newly minted git repository.</p>
<p>Doing it this way is important in that it ensures you have a completely clean copy of the generated output as your new website version instead of possibly missing an article deletion or restructuring that doesn't get tracked properly.</p>
<h3>Putting it all together</h3>
<p>This is the full action file ready to be copy/pasted and updated to your own settings.</p>
<div class="highlight"><pre><span></span><code><span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pelican-Publisher</span>

<span class="c1"># Run this workflow ever time a new commit is pushed ot the repo</span>
<span class="nt">on</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">push</span>

<span class="nt">jobs</span><span class="p">:</span>
  <span class="nt">publish</span><span class="p">:</span>
    <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Publish</span> 

    <span class="nt">runs-on</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span>

    <span class="nt">steps</span><span class="p">:</span>
      <span class="c1">## pull the committed code into an environment.</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Checkout Code</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">actions/checkout@v2</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Set up Python 3.9</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">actions/setup-python@v2</span>
        <span class="nt">with</span><span class="p">:</span>
          <span class="nt">python-version</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">3.9</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Install Dependencies</span>
        <span class="nt">run</span><span class="p">:</span> <span class="p p-Indicator">|</span>
          <span class="no">python -m pip install --upgrade pip</span>
          <span class="no">pip install -r requirements.txt</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Build Site</span>
        <span class="nt">run</span><span class="p">:</span> <span class="p p-Indicator">|</span>
          <span class="no">make publish</span>
      <span class="c1"># push generated site to public repo</span>
      <span class="p p-Indicator">-</span> <span class="nt">name</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Pushes to another repository</span>
        <span class="nt">id</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">push_directory</span>
        <span class="nt">uses</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">cpina/github-action-push-to-another-repository@v1.2</span>
        <span class="nt">env</span><span class="p">:</span>
          <span class="nt">API_TOKEN_GITHUB</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">${{ secrets.APITOKENPUBLISH }}</span>
        <span class="nt">with</span><span class="p">:</span>
          <span class="nt">source-directory</span><span class="p">:</span> <span class="s">&#39;output&#39;</span>
          <span class="nt">destination-github-username</span><span class="p">:</span> <span class="s">&#39;&lt;your</span><span class="nv"> </span><span class="s">github</span><span class="nv"> </span><span class="s">id</span><span class="nv"> </span><span class="s">here&gt;&#39;</span>
          <span class="nt">destination-repository-name</span><span class="p">:</span> <span class="s">&#39;&lt;your</span><span class="nv"> </span><span class="s">github</span><span class="nv"> </span><span class="s">id</span><span class="nv"> </span><span class="s">here&gt;.github.io&#39;</span>
          <span class="nt">user-email</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">&lt;your email address here so the commit is signed correctly&gt;</span>
          <span class="nt">commit-message</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">Automated Update</span>
          <span class="nt">target-branch</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">main</span>
</code></pre></div>


<h2>Adding Content</h2>
<p>In the process of writing this article I've gone from using VSCode to write it, to moving to ZETTLR, and then switching back to vscode for a few reasons.  Initially when I was developing this article in vscode I'd attempted to install a spell checker to make sure my writing is at least spelled right if not you know, comprehensible.  Unfortunately the recommended spell checker just seemed to freak out and highlight the entire markdown file as spelled incorrectly.  So I removed that addon and migrated over to editing in a zettlr window, this has some upsides I really liked. The spell checking is sane, rendering markdown 'live' as you edit it works incredibly well.  Unfortunately the folder handling is rather clunky, zettlr has opinions about how things are organized and they don't mesh with how I work as well as I thought.  Additionally the linux version seems to have some serious keyboard shortcut collisions that I didn't have the willpower to fix; when you are trying to paste with <code>ctrl+v</code> and it instead keeps warping you to the bottom of the page for some reason, it's time to stop fighting a tool not setup to do what you want. So I'm back to using vscode as my editor, however in the mean time I've found a different spellchecker for vscode that acts more sanely.  The <a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">Code Spell Checker</a> by Street Side Software works more or less how I'd expect. The only nagging point currently is having to hit <code>ctrl+.</code> instead of right clicking on a misspelled word in order to fix it.  All in all, it works and that's what's important here.</p>
<h2>Notes</h2>
<p>Below are notes and references used to work out the details above.</p>
<p>This blog is built and published using the <a href="https://docs.getpelican.com/en/3.6.3/index.html">Pelican static site generator system</a> in a two stage setup.</p>
<p>reference material on the current state of github pages:</p>
<p>actions reference materials:</p>
<ul>
<li>https://github.com/marketplace/actions/push-directory-to-another-repository</li>
<li>https://github.com/cpina/push-to-another-repository-example</li>
<li>https://nolanbconaway.github.io/pelican-deploy-gh-actions/pages/deployment-on-github-pages.html</li>
<li>https://docs.github.com/en/actions/quickstart</li>
</ul>
<p>currently using: github actions based on ubuntu-latest, python setup commands, and the push directory to another repository action.</p>
      </div>
      <div class="back-to-top">
          <a href="#top">back to top</a>
      </div>
    </article>
  </div>
<!-- end article -->
                <footer>
                    <div class="icons">
                        <a href="https://twitter.com/Wildcarde815" target="_blank"><div class="icon-twitter icon"></div></a>
                        <a href="https://github.com/Wildcarde" target="_blank"><div class="icon-github icon"></div></a>
                    </div>
                    <p>© <script>document.write(moment().format('YYYY'));</script> Garrett McGrath</p>
 
                    <p><i>"Brutal"</i> Pelican Theme</p>
                    <p>Designed and built by <a href="http://twitter.com/mcman_s">@mcman_s</a> in Denver</p>
                </footer>
        </div>
</body>
</html>